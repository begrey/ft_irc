# IRC는 무엇인가

> (위키피디아 영문 문서에 기반 [https://en.wikipedia.org/wiki/Internet_Relay_Chat](https://en.wikipedia.org/wiki/Internet_Relay_Chat))
> 

# 인터넷 릴레이 챗 (Internet Relay Chat)

---

IRC는 문자 기반 채팅 시스템이다. IRC는 channels이라 불리는 곳에서 그룹 대화를 위해 디자인 되었으나, private 메시지를 통한 1:1 대화도 가능하며, 대화와 파일 공유를 포함한 전송이 가능하다.

네트워크 프로그램인 IRC 클라이언트는 채널에 접근하는데 필요하다. IRC 클라이언트는 로컬 컴퓨터의 독립된 프로그램(e.g. mlRC, HexChat)일 수 있으며, 또는 어떤 거대한 프로그램의 특별한 유저 인터페이스로 형태를 취하기도 한다. IRC 클라이언트는 Mibbit, IRCCloud, KiwilRC 그리고 MIT의 The Lounge Chat등이 있다.

중계기로 작동하는 연결된 IRC 네트워크 서버는, IRC의 호출을 중재하는데 사용한다. 가장 큰 IRC 네트워크는 동시에 100,000명의 사용자와, 사람들이 일제히 참가할 수 있는 다양한 채널를 관리하는 IRC 서버로 이루어져 있다.

IRC는 문자 형식의 대화를 가능하게 하기 위해 어플리케이션 레이어로 구현되었다. 대화 프로세스는 client-server 네트워크 모델에서 작동한다.

## Technical information

---

IRC는 TCP와 선택적으로 TLS를 사용하는 개방형 프로토콜이다. IRC 서버는 IRC 네트워크를 확장하기 위해 다른 IRC 서버에 연결할 수 있다. 사용자는 서버에 클라이언트를 연결함으로써 IRC 네트워크에 접근한다. 이를 이행하기 위한 많은 클라이언트들이 있는데, mlRC, HexChat 그리고 irssi 와 같은 것이다. 그리고 서버 구현의 예로 IRCd가 있다. 대부분의 IRC 서버는 사용자를 위한 계정 등록을 요구하지 않지만, 연결 전 닉네임이 요구된다.

IRC는 본래 일반 텍스트 프로토콜을 사용하며(이후 확장되었다), request시 IANA로부터 194/TCP 포트를 할당받아 사용한다. 그러나, 사실상의 표준은 루트 권한으로 IRCd 소프트웨어의 실행을 피하기 위해, 대부분이 6667/TCP 혹은 가까운 포트(6660~6669, 7000)에서 IRC를 실행한다.

프로토콜은 문자에 대해 8비트임을 명시하였지만, 문자가 사용해야 할 문자 엔코딩은 명시하지 않는다. 이것은 사용자가 다른 클리이언트, 다른 플렛폼을 사용할 경우 문제를 야기할 수 있다.

오늘날 사용되는 client-to-server IRC 프로토콜들은 IRC2 서버의 irc2.4.0 버전에서 구현된 프로토콜의 후손이며, RFC 1459에 문서화되어 있다. RFC 1459가 개시된 이후, irc2의 새로운 기능들은 다음과 같다. 10개의 구현으로 인해 몇몇의 수정된 프로토콜 다큐먼트(RFC 2810, RFC 2811, RFC 2812 and RFC 2813)가 출판되었다; 그러나, 이 프로토콜 변화는 다른 구현에서 널리 채택되지 않았다.

많은 IRC의 설계 명세서들이 출판되어있지만, 프로토콜의 동적 특징을 유지하기 위해, 공식적인 설명서는 존재하지 않는다.

Microsoft는 독점 IRCX를 통해, 1998년, IRC의 extension을 만들었다. 그들은 이후 IRCX를 지원하는 소프트웨어의 배포를 중단하였고, 대신 독점 MSNP를 개발한다.

IRC 서버 네트워크의 스탠다드 구조는 트리이다. 메시지들은 트리에 필요한 가지를 통하여 발송되지만, 네트워크 상태는 모든 서버로 전송되며, 일반적으로 서버 간 높은 암묵적 신뢰를 가진다. 그러나, 이러한 아키택처는 여러가지 문제를 가졌다. 오작동 혹은 악의적인 서버는 네트워크에 심각한 손상을 야기할 수 있고, 의도적이든 기본 네트워크 조건의 결과이든, 구조상 모든 변화는, net-split과 net-join을 요구한다. 이러한 결과로 네트워크 트레픽이 많고, 사용자에게 거짓된 quit/join 메시지들, 그리고 분할 서버의 사용자에 대한 일시적 통신 손실이 있다. 거대한 네트워크에 서버를 추가하면, 네트워크에 백그라운드 대역폭 부하와, 서버의 메모리 부하가 커진다. 그러나, 일단 한번 설정되면, 여러 수신자에게 보내지는 메시지는 multicast와 유사한 방법으로 전송되며, 이는 각각의 메시지가 네트워크 링크를 단 한번만 통과함을 뜻한다. 이는 Simple Mail Transfer Protocol(SMTP) 혹은 Extensible Messaging and Presence Protocol(XMPP)와 같은 non-multicast 프로토콜과 비교해서 강점이라고 할 수 있다.

IRC 데몬은 local Area Network(LAN) 또한 사용할 수 있다. 따라서 IRC는 LAN의 사람들 사이의 통신을 용이하게 하는 데 사용할 수 있다.

### Commands and replies

IRC는 line-based 구조를 가졌다. 클라이언트들은 single-line 메시지들을 서버에 전송하며, 해당 메시지에 대한 응답을 수신하고, 다른 클라이언트로부터 전송된 메시지들의 사본을 수신받는다. 대부분의 클라이언트는, 사용자가 '/'로 시작하는 것으로 커맨드를 입력할 수 있다. 커맨드에 따라, 클라이언트의 전부를 제어할 수 있고, 혹은, 서버에 직접 전달하며, 일부를 수정할 수도 있다.

프로토콜의 특성에 따라서, 자동화된 시스템은 송신된 커멘드를 완전한 신뢰성으로 응답과 항상 올바르게 짝지을 수 없으며 추측의 대상이 된다.

### Channels

설정된 IRC 세션에서 사용자 그룹과 통신하는 기본 수단은 채널을 통하는 것이다. 네트워크의 채널은 특정 네트워크에서 '+s' 혹은 '+p' 모드 설정을 가지지 않은, 현재 사용 가능한 모든 채널들을 나열하는 LIST 커맨드를 사용 할 수 있다.

사용자는 JOIN 커맨드를 사용하여 채널에 참가할 수 있고, 대부분의 클라이언트는 "/join #chnnelname" 의 형태로 사용 가능하다. 참가한 채널에 메시지를 보내면, 모든 다른 사용자에게 릴레이한다.

전체 IRC 네트워크에서 사용할 수 있는 체널에는 '#'을 접두어로 가지고, 로컬 서버는 '&'을 접두어로 가진다. 다른 일반적인 채널 유형으로는 '+' 채널 - 연산자가 없는 'modeless' 채널 및 일반적으로 시간 스탬프가 없는 네트워크에서 타임스탬프로 된 채널의 한 형태인 '!' 채널이 있다.

### Modes

사용자와 채널은 단일 알파벳으로 대표되는 모드를 가지고 있고, 그것들은 MODE 커맨드를 사용하여 설정할 수 있다. Users modes 그리고 channel modes는 분리되어 있고, 같은 문자를 사용하되 다른 의미를 가질 수 있다. (예시: 사용자 모드 "i"는 보이지 않는 모드, 채널 모드 "i"는 초대 전용) 모드는 일반적으로 타겟(사용자 혹은 채널), (+) 또는 (-)를 설정하는 모드 집합, 모드에 필요한 모든 파라미터를 사용하는 MODE 커맨드를 사용하여 설정, 해제할 수 있다.

몇몇 채널 모드는 파라미터를 사용하고, 다른 채널 모드는 채널의 사용자에게 적용하거나 전체 채널에 적용하는 대신, 채널과 연결된 목록에서 mask(밴 마스크와 같은)를 추가 또는 제거한다. 채널 사용자에게 적용되는 모드는 이름 응답에서 모드를 나타내는 데 사용되는 관련 기호들을 가지고 있으며 (채널에 처음 가입하고 NAME 커맨드를 사용할 때 클라이언트에게 전송됨), 많은 클라이언트에서 채널의 사용자 표시 목록에 표시하거나, 사용제 모드에 대한 자체 표시기를 출력하기 위해 사용된다.

수신 모드 메시지를 올바로 구문 분석하고 채널 상태를 추적하려면, 클라이언트는 어떤 모드가 어떤 유형의 모드인지, 어떤 기호가 어떤 문자와 함께 사용되는지를 알기 위해, 채널의 사용자에게 적용되는 모드를 반드시 알아야한다. IRC의 초기 구현에서는, 클라이언트에서 이를 하드 코딩해야 했지만, 현재는 ISUPPORT라고 풀리는 프로토콜이라고 하는 사실상의 스탠다드 extension이 있으며, 이는 숫자 005를 사용하여 연결 시 해당 정보를 클라이언트에 전송한다.

채널에서 사용자에게 적용되는 모드와 관련하여, IRC의 설계상 작은 결함이 있다: 초기 상태를 설정하는 데 사용되는 이름 메시지는 채널에서 사용자당 하나의 모드만 전송할 수 있다. 그러나 이러한 모드는 한 사용자에게 다중으로 설정될 수 있다. 예를 들어, 만약 채널에서 한 사용자가 operator 상태 ('+o)와 보이스 상태 ('+v)를 가졌다면, 새 클라이언트는 낮은 우선순위로 모드를 볼 수 없다. 이를 위한 해결 방법은 클라이언트와 서버 양쪽에서 모두 가능하지만, 대부분은 구현되어있지 않다.

 **Standard (RFC 1459) modes**

*[ User modes ]*

| Letter | Symbol | Description |
| --- | --- | --- |
| i |  | invisible - 공통된 채널 혹은 정확한 이름 없이는 볼 수 없음 |
| s |  | 서버 알림 수신 |
| w |  | wallops(IRC네트워크에서 메시지를 보내는 데 사용되는 명령이다. wallops 메시지는 네트워크 정보와 사용자들의 상태를 브로드케스트하기 위함이다.) 수신 |
| o |  | IRC 오퍼(관리자) |

*[ Channel modes ]*

| Letter | Symbol | Parameter(s) | Description |
| --- | --- | --- | --- |
| o | @ | 대상 유저의 이름 | Channel operator |
| s |  |  | Secret channel |
| p |  |  | Private channel |
| n |  |  | 사용자가 외부에서 채널로 메시지를 보낼 수 없음 |
| m |  |  | 채널 조정 (채널 관리자 혹은 채널에서 보이스 상태를 유지하는 사람만 채널로 메시지를 전송할 수 있음) |
| i |  |  | 초대된 사용자만 채널에 들어올 수 있음 |
| t |  |  | 오직 채널 관리자만 채널 토픽을 변경할 수 있음 |
| l |  | 제한할 명 수 | 채널 참가 인원수 제한 |
| b |  | 밴 마스크 | 채널의 밴 호스트마스크 |
| v | + | 대상 유저의 이름 | 대상 사용자에게 채널의 보이스 상태를 줌 (위의 m 참고) |
| k |  | 새로운 채널 키 | 채널 키를 알아야만 채널에 들어올 수 있음 |

### Channel operators

채널 관리자는 IRC 채널을 관리하는 해당 채널의 한 클라이언트이다. IRC 채널 관리자는 닉네임에 심볼이나 아이콘을 통해 쉽게 확인할 수 있다. 관리자가 가능한 행위는 다음과 같다:

- 사용자 강퇴(kick)
- 사용자 밴
- 다른 사용자에게 IRC 채널 관리자 상태 혹은 IRC 채널 보이스 상태 임명
- IRC 채널의 토픽 변경 (채널 모드 +t 설정)
- IRC 채널 모드 잠금

### IRC operators

로컬 서버 혹은 전체 네트워크에는 상승된 직급을 가진 사용자(스탭?) 또한 필요한데, 이들을 'IRC  operator' 라고 하며, 때때로 IRCops 혹은 Oper로 단축해서 불리기도 한다. IRCd의 구현이 다양함에 따라, 주어진 IRCd에 대한 IRC 운영자의 특권(권한)도 다양하다. RFC 1459는 IRC 관리자를 네트워크의 상태를 깨끗이 유지하기 위한 "필요악"(???)으로 규정하고 있으며, 따라서 서버 연결을 끊고 다시 연결할 수 있어야 한다고 주장한다. 게다가, 악의적인 사용자를 막거나, 유해한 자동 프로그램이 IRC에 들어오는 것을 방지하기 위해, IRC 관리자는 일반적으로 클라이언트 연결을 끊고, IP 주소나 서브넷을 완전히 밴할 수 있다. 서비스를 제공하는 네트워크는 보통 IRC 관리자가 기본적인 "ownership" 문제도 처리할 수 있도록 한다.

### Hostmasks

Hostmasks는 IRC 서버에 연결된 IRC 클라이언트의 특별 식별자이다. IRC 서버, 서비스 및 봇을 포함한 다른 클라이언트는 이를 통해 특정 IRC 세션을 식별할 수 있다.

hostmask의 포맷은 `nick!user@host`와 같다. hostmask는 e-mail 주소와 비슷하나 혼동해서는 안된다.

`nick` 파트는 사용자에 의해 선택된 닉네임이고, 연결되있는 중에도 바꿀 수 있다. `user` 파트는 클라이언트의 ID로부터 보고된 사용자 이름이다. 만약 클라이언트에서 ID를 사용할 수 없는 경우, 접두에 물결표가 붙은 후 클라이언트가 연결할 때 지정한 사용자 이름이 사용된다.

`host` 파트는 클라이언트가 연결중인 호스트 이름이다. 만약 클라이언트의 IP 주소를 유효항 호스트 이름으로 확인할 수 없다면, hostname 대신 사용한다.

IP 주소 혹은 클라이언트의 hostname 공개에 따른 프라이버시 문제를 이유로, 몇몇 IRC 데몬은 InsplIRCd 혹은 UnreallRCd's('s +x)와 같은 프라이버시 기능 또한 제공한다. 사용자는 추가적인 익명성을 위해, "virual host"를 hostmask에 표기하도록 할 수 있다.

### URI scheme

IRC를 위한 3가지의 URI (Uniform resource identifier) 스케마(정책)가 있다: `irc`, `ircs`, `irc6`. 지원하는 경우 다음을 포함한 다양한 형태의 하이퍼링크를 허용한다.

```
irc://<host>[:<port>]/[<channel>[?<channel_keyword>]]
ircs://<host>[:<port>]/[<channel>[?<channel_keyword>]]
irc6://<host>[:<port>]/[<channel>[?<channel_keyword>]]
```

(괄호([,]) 로 둘러싸인 요소들은 선택사항) 필요한 경우, 지정 호스트에 대한 연결 그리고 지정 채널에 대한 참가를 위해 사용된다. (클라이언트 자체에서 사용할 수 있거나, 웹 브라우저와 같은 다른 어플리케이션에서 사용할 수 있다.) irc는 기본 URI이고, IPv6를 사용한 연결을 위한 irc6, 그리고 보안 접속을 위한 ircs가 있다.

규격에 따라, 일반적으로 해시 심볼(#)이 채널 이름(영문 알파벳 혹은 숫자로 시작하는)앞에 붙지만, 생략 가능하다. 일부 구현에서는(ex. mIRC) URL에 포함된다면, 무조건적으로 추가(ex. ##channel)가 발생한다.

일부 구현에서는 다수을 채널 명시가 가능하고, 컴마(.)로 구분된다.